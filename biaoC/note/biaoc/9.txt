

指针变量也是变量
指针变量只能记录地址数据
指针变量和普通变量的使用方法完全不同
指针变量的主要作用就是用来找一个普通
    变量的
只有记录了有效地址的指针才能用来找
    普通变量(指针变量的使用有前提
    条件)
指针变量也需要先声明然后才能使用
声明指针变量时需要在变量名称前加*
当一个指针记录了某个存储区的地址以后
   就可以说这个指针指向这个存储区
当一个指针指向一个存储区以后就可以在
   指针前使用*操作符,这种写法就可以
   表示指针指向的那个存储区

通过指针找到的那个存储区的类型只能是
    声明指针时所提供的类型
int *p_val;
...  (让指针指向某个存储区)
*p_val(这个存储区的类型只能是整数类型)

可以在一条语句里声明多个同类型指针,
    这个时候需要在每个指针变量前
    单独加*

typedef关键字可以用来给数据类型起别名,
    程序里可以用别名代替原来的类型名称
指针类型通常可以起别名
用指针类型别名声明指针变量的时候就不
    需要再加*了

没有记录有效地址的指针分为两类
1.空指针里固定记录空地址(NULL),
    这个地址的数值就是数字0
2.其他没有记录有效地址的指针都
    叫做野指针

程序里不可以出现野指针
所有指针变量必须初始化

指针初始化的时候*没有参与赋值过程

指针指向的存储区可以随着程序的执行
    不断变化
这个时候可以把指针看做是存储区的某种
    身份或特征

当一个指针指向数组里第一个存储区之后
   可以通过这个指针找到数组里的每个
   存储区
这个时候可以使用指针代表整个数组

地址数据只能参与以下计算过程
地址 + 整数   地址 - 整数   地址 - 地址
地址加减整数n实际加减的是n个指向
    存储区的大小
int arr[5];
   0    1    2    3    4
 **** **** **** **** ****
 ^         ^
 *         *
 *         *
 arr       arr + 2

数组里第一个存储区的地址加下标可以
   得到下标对应存储区的地址

以下两种写法可以用来表示数组里的存储区
*(arr + num) 或   *(p_val + num)
其中arr是数组名称,p_val是指向
    数组里第一个存储区的指针,num是下标

地址之间做减法结果是一个整数,这个整数
    表示两个地址之间包含的指向存储区
    的个数

int arr[5];
    0    1    2    3    4
  **** **** **** **** ****
  ^         ^
  *         *
  *         *
  arr       &arr[2]

&arr[2] - arr结果是2

可以使用指针作为循环变量依次处理数组
    里的每个存储区
在循环里指针应该依次指向数组里的每个
    存储区

声明指针变量的时候可以使用const关键字

如果在声明指针变量的时候把const关键字
    写在类型名称前就表示不可以通过这个
    指针对它指向的存储区做赋值,但是可以
    对指针本身做赋值.

如果在声明指针变量的时候把const关键字
    写在指针变量名称前就表示可以通过
    这个指针对它指向的存储区做赋值,但是
    不可以对指针本身做赋值

声明指针变量时可以使用void作为类型名称
可以把这种指针叫做无类型指针
这种指针没有告诉我们它指向的存储区
    是什么类型的
不应该在这种指针前使用*操作符或者
    对这种指针进行加减整数的计算
这种指针使用前需要先强制类型转换成
    有类型指针

可以在调用函数和被调用函数之间传递
    存储区(一个函数把自己的存储区
    给别的函数使用)
只要把存储区的地址传递给别的函数就
    可以实现传递存储区的效果
只能使用指针记录别的函数传递过来的地址

数组做形式参数的时候真正的形式参数其实
    是一个指针,它指向数组里第一个存储区

声明指针形式参数的时候尽量使用const
    关键字

无类型指针经常作为形式参数使用
可以通过无类型指针形式参数把任意
    类型的存储区传递给被调用函数

可以在被调用函数里把存储区的地址当
    返回值,这样就可以从被调用函数
    向调用函数传递存储区

只有符合生命周期规则的存储区才可以
    在函数之间传递(不可以把非静态
    局部变量存储区的地址做返回值使用)

预习:
    1.字符串



