蒋贵良
标准C++(11days)、Qt、模板和stl
------------------------------
《C++ Primer》
《C++程序设计原理与实践》
------------------------------
一 C++语言概述//了解
1 历史背景
1）C++的江湖地位
   java、C、python、C++、C#
2）C++之父：Bjarne Stroustrup(1950--)
--》1979，Cpre，为C语言增加类的机制
--》1983，全新编程语言 C with Class，后来就是C++
--》1985，CFront1.0
         《The C++ Programming Language》
3）C++发展过程
--》1987，GNU C++
--》1990，Borland C++
--》1992，Microsoft C++(VC)
    ......
--》1998，ISO C++98
--》2003，ISO C++03
--》2011，ISO C++11
--》2014，ISO C++14
--》2017，ISO C++17
--》2020，ISO C++20
...

2 应用领域
1）游戏开发
2）科学计算
3）网络和分布式应用
4）操作系统和设备驱动
5）其它...

3 C和C++
1）都是编译型语言
2）都是强类型语言，但是C++更强
3）C++去除了C中不好的特性
4）C++增加了很多C中没有的好的语法特性，全面支持面向对象，比C语言更适合大型软件开发。

二 第一个C++程序
1 编译方式
1）gcc xx.cpp -lstdc++
2）g++ xx.cpp //推荐

2 文件扩展名
1）.cpp //推荐
2）.cxx
3）.cc
4）.C

3 头文件
#include <iostream>
--》C++中和I/O相关类型、对象、函数都在该头文件中
--》C++中绝大多数头文件没有.h后缀
--》C++开发中，可以直接使用C语言头文件，同时还提供了一套不带.h的替换版本
eg:
	#include <stdio.h> ==> #include <cstdio>
	#include <stdlib.h> ==> #include <cstdlib>
	#include <string.h> ==> #include <cstring>
	...

4 标准输入和输出
1）使用cin对象表示标准输入//类似scanf()
	int i;
	scanf("%d",&i);//C
	cin >> i;//C++
	------------------------------
	int i,doubld d;
	scanf("%d%lf",&i,&d);//C
	cin >> i >> d;//C++
	注：">>"输入操作符
	
2）使用cout对象表示标准输出//类似printf()
	int i = 123;
	printf("%d\n",i);//C
	cout << i << endl;//C++
	注："<<"输出操作符
	----------------------------
	int i = 123,double d = 4.56;
	printf("%d,%lf\n",i,d);//C
	cout << i << ',' << d << endl;//C++
    	  	
三 名字空间(命名空间)
1 功能
1）避免名字冲突
2）划分逻辑单元

2 定义名字空间
	namespace 空间名{
		名字空间成员1;
		名字空间成员2;
		...
	}
	注：名字空间成员可以是全局函数、全局变量、自定义类型、名字空间.

3 名字空间成员使用
1）通过作用域限定操作符"::"
	空间名::要访问成员;
   eg:
   "std::cout"表示使用标准名字空间里面cout  
2）名字空间指令
	using namespace 空间名;
	在该条指令以后的代码中，指定名字空间成员都可以见，可以直接访问，省略"空间名::"
3）名字空间声明
	using 空间名::名字空间成员;
	将名字空间中特定一个成员引入到声明所在的作用域中，在该作用域访问这个成员就如同是访问自己的成员一样，可以直接访问，省略"空间名::"
	
4 全局作用域和无名(匿名)名字空间 //了解
1）没有放在任何名字空间的成员，属于全局作用域，可以直接访问，如果和局部作用域的成员名字一样，局部优先；这时如果还希望访问到全局作用域的成员，可以通过“::成员”形式来显式指明.
2）定义名字空间时，可以没有名字，即为无名名子空间，对于无名空间里面的成员和全局作用域的成员一样，也可以直接访问，只是被局限在当前文件中.
5 名字空间嵌套//了解
eg:
  namespace ns1{
  		int num = 10;
  		namespace ns2{
  			int num = 20;
  			namespace ns3{
  				int num = 30;
  			}
  		}
  }
  cout << ns1::num << endl;//10
  cout << ns1::ns2::num << endl;//20
  cout << ns1::ns2::ns3::num << endl;//30
  
四 C++的结构体、联合体和枚举
1 结构体
1）当定义结构体变量时可以省略struct关键字
2）在结构体内部可以直接定义函数，称为成员函数(方法)，在成员函数中可以直接访问当前结构体中的其它成员。

2 联合体//了解
1）当定义联合体变量时可以省略union关键字
2）支持匿名联合
	
3 枚举
1）当定义枚举变量时，可以省略enum关键字
2）C++中枚举被看做是独立的数据类型，而C中枚举本质就是整型数
	enum STATE{SLEEP,RUN,STOP};
	STATE s;
	s = STOP;//C:ok,C++:ok
	s = 2;//C:ok,C++:error

五 字符串
1 回顾C中字符串
1）字面值常量 “hello”
2）字符指针 char* 
3）字符数组 char[]
eg：
	char* p1 = "abcdef";
	char* p2 = "123456";
	strcpy(p1,p2);//段错误
	-------------------------
	char arr1[] = "hello";
	char arr2[] = "wangjianli";
	strcpy(arr1,arr2);//内存越界，危险！
	--------------------------
	char arr[] = "hello";
	char* p = "world";
	p = arr;//ok
	arr = p;//error
	--------------------------

2 C++兼容C中字符串表示方式，同时增加了string类型转换表示字符串:
1）定义 
	string s;//定义空字符串
	string s = "xx";//定义同时初始化
	-----------------------------------
	//下面两种写法实际初始化过程和上面相同
	string s("xx");
	string s = string("xx");
2）字符串拷贝：=
   string s1 = "hello";
   string s2;
   s2 = s1;//拷贝
3）字符串连接：+ +=
	string s1 = "abc";
	string s2 = s1 + "def";
	cout << s2 << endl;//"abcdef"
4）字符串比较：== != > < >= <=
	if(s1 == s2){...}
5）随机访问：[]
	string s = "hello";
	s[0] = 'H';
6）成员函数
	size()/length();//获取字符串长度
	c_str();//获取C风格的字符串(const char*)

练习：使用string类型，从键盘读取一个字符串，统计里面包含字符“A”/“a”的个数.
提示：
		string str;
		cin >> str;//从键盘读取一个字符串
		

练习：使用string类型，从键盘读取一个字符串，将字符串反转，再打印输出
提示：
	输入：hello
	输出：olleh

www.cplusplus.com//C++官网网站，包括完整帮助手册


回顾：
1 C++语言概述：C++98、C++11/C++0x
2 第一个C++程序
1）g++ xx.cpp、gcc xx.cpp -lstdc++
2）.cpp
3）头文件：iostream、cstdio
4）cout、cin
3 名字空间(namespace)
1）定义
   namespace 空间名{名字空间成员;...}
2）名字空间成员使用
--》空间名::成员;
--》名字空间指令,using namespace std;
--》名字空间声明,using 空间名::成员;
3）全局作用域和无名空间，"::成员"
4）名字空间嵌套

4 C++结构体、联合体和枚举

5 C++字符串：string
1）定义: string s="xx";
2）操作：= +/+= ==/!=/>/</>=/<= []
3）成员函数：size()/length()  c_str()

-----------------------------
今天：
六 C++的布尔类型：bool
1 bool类型是C++中基本数据类型，专门表示逻辑值，逻辑真为true，逻辑假为false
2 bool类型在内存占一个字节：1表示true，0表示false
3 bool类型变量可以接收任意类型表达式的结果，数值非零则为真，为零则为假。
	bool isEmpty(void){
		...
		return true/false;
	}

七 操作符别名//了解
	&& <==> and
	|| <==> or
	^  <==> xor
	{	<==> <%
	}  <==> %>
	...
	
八 C++的函数
1 函数重载(overload)
1）定义
	在相同作用域，可以定义同名的函数，但是它们的参数必须有所区分，这样的函数关系称为函数重载.
	注：函数重载和返回类型无关.
	
eg:图形库中绘图函数
	void drawRect(int x,int y,int w,int h){...}
	void drawCircle(int x,int y,int r){...}
	...
	------------------------------------------
	void draw(int x,int y,int w,int h){...}
	void draw(int x,int y,int r){...}
	...
2）函数重载匹配
   调用函数时，编译器根据实参和形参匹配程度，自动选择最好的重载版本.
  当前g++编译器匹配的优先级：
  完全匹配>=常量转换>升级转换>降级转换>省略号匹配
3）函数重载原理
	C++的编译器是通过函数换名，将参数表的类型信息整合到新的函数名中，实现解决函数重载和名字冲突的矛盾。  
	笔试题：C++中extern "C"声明作用？
	可以在函数声明前面加入 extern "C"，要求C++编译器不要对该函数进行换名，便于C程序直接调用。
	注：被extern "C"声明的函数无法重载

2 函数的哑元参数
1）定义
	定义函数时,只有类型而没有变量名形参被称为哑元.
	void func(int/*哑元*/){...}
2）使用哑元场景
--》操作符重载，通过哑元区分前后++/--(后面讲)
--》兼容旧代码
eg:
	//算法库：
	void math_func(int a,int b){...}
	//使用者
	int main(void){
		math_func(10,20);
		...
		math_func(30,40);
	}
	=========================================
	//算法库升级：
	void math_func(int a,int/*哑元*/){...}
	//使用者
	int main(void){
		math_func(10,20);
		...
		math_func(30,40);
	}

3 函数的缺省参数(默认实参)
1）可以为函数的参数指定缺省值，调用该函数时，如果不给实参，就会取缺省值作为默认实参.
	void func(int a,int b=0/*缺省参数*/){...}
2）靠右原则，如果函数的某个参数有缺省值，那么该参数右侧的所有参数都必须带有缺省值.
3）如果函数声明和定义分开写，缺省参数应该写在函数的声明部分，而定义部分不写.
	void func(...);//函数声明
	void func(...){...}//函数定义
	
4 内联函数(inline)
1）使用inline关键字修饰的函数即为内联函数，编译器将会尝试进行内联优化，可以避免函数的调用开销，提高代码执行效率.
	inline void func(void){...}
2）使用说明
--》多次调用的小而简单的函数适合内联
--》调用次数极少或者大而复杂的函数不适合内联
--》递归函数不能内联
--》虚函数不能内联(后面讲)
注：内联优化只是一种建议而不是强制要求，一个函数能否内联优化主要取决于编译器，有些函数不加inline修饰也会默认处理为内联优化,有些函数即便加了inline修饰也会被编译器忽略掉.

九 C++的动态内存管理
1 回顾C中动态内存管理
1）分配：malloc()
2）释放：free()

2 C++的动态内存管理
1）分配：new、new[]
2）释放：delete、delete[]

十 C++的引用(Reference)
1 定义
1）引用即别名，就是某个变量的别名，对别名操作和对变量本身操作完全相同.
2）语法
	类型 & 引用名 = 变量名;
	注：定义引用时必须初始化，初始化以后绑定的目标变量不能再修改。
	注：引用的类型和绑定目标变量类型一致。
eg：
	int a = 100;
	int & b = a;//b就是a的别名
	b++;
	cout << a << endl;//101

2 常引用
1）定义引用时加const修饰，即为常引用，不能通过常引用修改目标变量.
	const 类型 & 引用名 = 变量名;
	类型 const & 引用名 = 变量名;//和上面完全等价
eg:
	int a = 100;
	const int& b = a;//b就是a的常引用
	b++;//error

2）普通的引用也可以称为左值引用，只能引用左值不能引用右值；而常引用也可以称为万能引用，既可以引用左值也可以引用右值。

注：关于左值和右值
左值(lvalue):可以放在赋值操作符左侧，可以被修改
右值(rvalue):只能放在赋值操作符右侧，不能被修改

练习：测试下面运算表达式，哪个结果是左值或右值？
	int a = 3 , b = 5;
	a + b;
	a += b;
	++a;
	a++;
	 
回顾：
1 布尔类型bool
2 操作符别名
3 C++的函数
1）函数重载，extern "C"
2）哑元参数，void func(int/*哑元*/){..}
3）缺省参数，void func(int a,int b=0){..}
4）内联函数，inline void func(void){..}

4 C++动态内存管理
1）分配：new/new[]
2）释放：delete/delete[]

5 引用(Reference)
1）引用即别名
2）定义： 类型 & 引用名 = 变量名;
3）常引用(万能引用)
	const 类型 & 引用名 = 变量名;	
4）关于左值(lvalue)和右值(rvalue)
	int a = 3,b = 5;
	int& r1 = a+b;//no
	int& r2 = ++a;//ok
	int& r3 = a++;//no
	int& r4 = (a+=b);//ok
	
---------------------------------
今天:
十 C++的引用(Reference)	
...
3 引用型函数参数
1）可以将 引用用于函数参数，这时形参就是实参的别名，可以通过形参直接修改实参，同时传递引用型参数可以避免参数值传递的过程，减小函数调用的开销，提高代码执行效率.
2）引用型参数有时可能会意外的修改实参值，如果传递引用型参数仅是为了提高传参效率，不想修改实参值，可以附加const修饰，将参数定义为常引用，提高传参效率的同时还可以接收常量型的实参.

4 引用型函数返回值
1）可以将 引用用于函数的返回值，这时函数返回结果就是return后面数据的别名，可以避免返回值的开销，提高代码的效率.
2）如果函数返回数值是左值引用，那么函数调用表达式结果就也是左值.

注：不要从函数中返回局部变量的引用，因为所引用的目标变量内存会在函数返回以后被释放，使用危险！可以从函数中返回成员变量、静态变量、全局变量的引用.

5 引用和指针
1）从C角度看待引用，其本质就是指针，但是C++开发中推荐使用引用而不是指针
	int i = 100;
	int* const pi = &i;
	int& ri = i;	
	*pi <==> ri 
2）指针定义时可以不做初始化，指针的目标也可以修改(指针常量除外);而引用在定义时必须初始化，而且初始化以后其目标不能再修改.
	int a = 3,b = 5;
	int* p;//ok
	p = &a;//p指向a的地址
	p = &b;//p指向b的地址
	-------------------
	int& r;//error
	int& r = a;
	r = b;//不是修改目标，仅是赋值操作

//往下了解：
3）可以定义指针的指针(二级指针)，但是不能定义引用的指针.
	int a = 10;
	int* p = &a;
	int** pp = &p;//ok,二级指针
	---------------------------
	int& r = a;
	int&* pr	= &r;//error,引用的指针
	int* pr = &r;//ok,但就是普通指针
	
4）可以定义指针的引用(指针变量的别名)，但是不能定义引用的引用
	int a = 10;
	int* p = &a;
	int*& rp = p;//ok,指针的引用
	------------------------------
	int& r = a;
	int&& rr = r;//error,引用的引用
	int& rr = r;//ok,但就是普通引用

5）可以定义指针数组，但是不能定义引用数组，可以定义数组引用(数组的别名)
	int a=10,b=20,c=30;
	int* parr[3] = {&a,&b,&c};//ok,指针数组
	int& rarr[3] = {a,b,c};//error,引用数组
	-------------------
	int arr[3] = {a,b,c};
	int (&rarr)[3] = arr;//ok,数组引用
6）可以定义函数指针，也可以定义函数引用(函数的别名)，语法特性一致。
	void func(int i,double d){...}
	int main(void){
		void (*pfunc)(int,double) = func;//函数指针
		void (&rfunc)(int,double) = func;//函数引用
		pfunc(10,1.23);
		rfunc(10,1.23);
		return 0;
	}

十一 类型转换
1 隐式类型转换
  char c = 'q';
  int i = c;//隐式
  -----------------
  void func(int i){}
  func(c);//隐式
  -----------------
  int func(void){
  		return c;//隐式
  }

2 显式类型转换
1）C++中兼容C中强制转换
  char c = 'q';
  int i = (int)c;//C风格
  int i = int(c);//C++风格，本质和上面一样

2）C++扩展的四种操作符形式的显式转换
--》静态类型转换
语法：
	目标变量 = static_cast<目标类型>(源类型变量);
适用场景：
	用于将void*转换为其它类型指针.
--》动态类型转换(后面讲)
语法：
	目标变量 = dynamic_cast<目标类型>(源类型变量);
	
--》常类型转换
语法：
	目标变量 = const_cast<目标类型>(源类型变量);
适用场景：
	用于去除指针或引用的常属性.	
	
--》重解释类型转换
语法：
  目标变量=reinterpret_cast<目标类型>(源类型变量)
适用场景：
  ->在指针和整型数之间进行转换
  ->任意类型指针或引用之间进行转换	

  eg:向物理内存地址0x12345678,存放数据“123”
  int* paddr=reinterpret_cast<int*>(0x12345678);
  *paddr = 123;


小结：来自C++社区给C程序员建议
1 慎用宏,可以使用const、enum、inline
#define PAI 3.14
	--> const double PAI = 3.14;

#define SLEEP 0
#define RUN  1
#define STOP 2
	--> enum STATE{SLEEP,RUN,STOP};  

#define Max(a,b) ((a)>(b)?(a):(b)) 
	--> inline int Max(int a,int b){
				return a > b ? a : b;
		 }	
2 变量随用随声明同时初始化
3 尽量使用new/delete取代malloc/free
4 少用void*、指针计算、联合体和强制转换
5 尽量用string表示字符串，少用C风格char*/char[]
-----------------------------------------------

十二 类和对象//了解
1 什么是对象
  万物皆对象，任何一种事物都可以看做是对象
  
2 如何描述对象
  通过对象的属性(名词、数量词、形容词)和行为(动词)来描述和表达对象。
  
3 面向对象程序设计
  对自然世界中对象的观察引入到编程实践的一种理念和方法，这种方法被称为“数据抽象”，即描述对象时把细节的东西剥离出去，只考虑有规律性、一般性的、统一性的东西.
  
4 类
  类是将多个多个对象共性提取出来定义的一种新的数据类型，是对象 对象属性和行为的抽象描述.
  现实世界				 类					虚拟世界
  具体对象--抽象-->属性/行为--实例化-->具体对象	  
十三 类的定义和实例化
1 类的一般语法形式
  struct/class 类名:继承方式 基类{
  访问控制限定符:
  		类名(参数表):初始化列表{...}//构造函数
  		~类名(void){...}//析构函数
  		返回类型 函数名(参数表){...}//成员函数
  		数据类型 变量;//成员变量
  };
2 访问控制限定符
1）public：公有成员，任何位置都可以访问
2）private：私有成员，只有类中自己的成员函数可以问
3）protected：保护成员(后面讲)
注：struct定义类，类中成员的缺省访问控制属性是public，而如果使用class定义类，类中成员的缺省访问控制属性是private。
eg：
	struct/class XX{
		int a;//公有成员/私有成员
	private:
		int b;//私有成员
	public:
		int c;//公有成员
		int d;//公有成员
	private:
		int e;//私有成员
	};

项目：企业员工管理系统V1.0
需求：实现描述企业员工类
	1）工号大于10000
	2）姓名字符串长度小于20字符	
	3）工资大于0
	4）工资计算=基本工资+绩效工资
	   基本工资=工资*出勤率(输入出勤天数/23.0)
	   绩效工资=基本工资/2
提示：
	class Employee{
		//行为：打印信息、计算工资
		//属性：工号、姓名、工资
	};
	
回顾：
1 引用
1）引用型函数参数
2）引用型函数返回值
3）引用和指针

2 类型转换
1）静态类型转换 static_cast
2）常类型转换 const_cast
3）重解释类型转换 reinterpret_cast

3 类和对象
------------------
今天：
十三 类的定义和实例化
1 类的一般语法形式
  struct/class 类名:继承方式 基类{
  访问控制限定符:
  		类名(参数表):初始化列表{...}//构造函数
  		~类名(void){...}//析构函数
  		返回类型 函数名(参数表){...}//成员函数
  		数据类型 变量;//成员变量
  };
2 访问控制限定符
1）public：公有成员，任何位置都可以访问
2）private：私有成员，只有类中自己的成员函数可以问
3）protected：保护成员(后面讲)

3 构造函数(Constructor)
1）语法
	class 类名{
		类名(形参表){
			//主要负责初始化对象，即初始化成员变量
		}
	};
2）函数名和类名相同，没有返回类型
3）构造函数在创建对象时自动被调用，不能像普通函数显式的调用
4）在每个对象的生命周期，构造函数一定会被调用，但仅会被调用一次

练习：实现一个电子时钟类，要求使用构造函数初始化时钟为当前的系统时间，并以秒为单位运行。
提示：
	class Clock{
	public:
		构造函数(time_t t){
			tm* local = localtime(&t);
			时 = local->tm_hour;
			分 = local->tm_min;
			秒 = local->tm_sec;
		}
		void run(void){
			while(1){打印当前时间;计时+1秒;sleep(1);}
		}
	private:
		int 时,分,秒;	
	};
	int main(void){
		Clock clock(time(NULL));
		clock.run();
		return 0;
	}

4 对象的创建和销毁
1）在栈区创建单个对象//重点掌握
   类名 对象名(构造实参);//直接初始化
   类名 对象名=类名(构造实参);//拷贝初始化,实际等价
2）在栈区创建多个对象(对象数组)
	类名 对象数组[元素个数] = {类名(构造实参),...};
3）在堆区创建/销毁单个对象//重点掌握
	类名* 对象指针 = new 类名(构造实参);
	delete 对象指针;
4）在堆区创建/销毁多个对象
	类名* 对象指针 = 
		new 类名[元素个数]{类名(构造实参),...};
	delete[] 对象指针;

	注：使用new操作符创建对象时,首相会分配内存,然后自动调用构造函数完成对象的初始化操作;而如果使用malloc仅能实现内存分配，不会调用构造函数。

5 多文件编程
1）类的声明放在xx.h中
2）类的实现放在xx.cpp中	


十四 构造函数和初始化列表
1 构造函数可以重载、也可以带有缺省参数

2 缺省构造函数(无参构造函数)
1）如果类中没有定义任何构造函数，编译器会提供一个缺省的无参构造函数:
-->对于基本类型的成员变量不做初始化
-->对于类 类型的成员变量(成员子对象)，将会自动调用相应类的无参构造函数来初始化。
2）如果自己定义了构造函数，无论是否有参数，编译器都不会再提供缺省无参构造了。

3 类型转换构造函数(单参构造函数)
  class 类名{
  		[explicit] 类名(源类型 ){...}
  };
  可以实现将源类型变量转换为当前类类型对象。
  注：使用explicit关键字修饰类型转换构造函数，可以强制这种转换必须要显式的完成.

4 拷贝构造函数(复制构造函数)
1）用已存在的对象，作为同类型对象的构造实参，创建新的副本对象，将调用该类的拷贝构造函数
  class 类名{
  		类名(const 类名&){...}
  };
  class A{...};
  A a1;
  A a2(a1);//A a2 = a1;

2）如果类中没有定义拷贝构造函数，那么编译器会为该类提供一个缺省的拷贝构造函数：
--》对于基本类型成员变量，按字节复制
--》对于类类型成员变量(成员子对象)，自动调用相应类的拷贝构造函数来初始化。

注：一般不需要自定义拷贝构造函数，应为缺省的拷贝构造函数已经很好用了.

3）拷贝构造函数的调用时机
--》用已定义对象作为同类型对象的构造实参
--》以对象形式向函数传递参数
--》从函数中返回对象(有时会被编译器优化)

5 初始化列表
1）语法
	class 类名{
		类名(参数表):成员变量(初值),成员变量(初值)...{
			函数体;
		}
	};
eg:
 	//先定义成员变量，再赋初值
 	Student(const string& name,int age,int no){
        m_name = name;
        m_age = age;
        m_no = no; 
   } 
	//定义成员变量同时初始化
 	Student(const string& name,int age,int no)
 		:m_name(name),m_age(age),m_no(no){} 
2）多数情况使用初始化列表和在构造函数体赋初值没有太大区别，两者可以任选；但是有特殊场景，必须要使用初始化列表；比如，类中如果包含了类类型的成员变量(成员子对象)，而该类有没有无参构造函数，或者希望以有参的方式来初始化该成员子对象，则必须使用初始化列表。

项目：企业员工管理系统V2.0
需求：优化企业员工类
1）为员工类增加构造函数(无参、有参)
2）创建员工对象时，使用两种方式(栈区、堆区)
3）将类的声明和实现分开，类的声明放在头文件，实现放在源文件中.
*4）尝试编写Makefile(make)
   《跟我一起写Makefile》--陈皓	

回顾：
1 类的定义和实例化
1）访问控制属性：public、private
2）构造函数
	class 类名{
		类名(参数表){//负责对象初始化}
	};
3）对象创建和销毁
栈区：类名 对象(构造实参);
堆区：类名* 对象指针 = new 类名(构造实参);
      delete 对象指针;
4）多文件编程
xx.h//类的声明
	class XX{
		XX(...);
		返回类型 函数名(...);
		数据类型 变量名;
	};
xx.cpp//类的实现
	XX::XX(...){...}
	返回类型 XX::函数名(...){...}
	
十四 构造函数和初始化列表
1 构造函数可以重载，可以带有参数
2 缺省构造函数(无参构造函数)
3 类型转换构造函数(单参构造函数),explicit
4 拷贝构造函数，类名(const 类名& ){...}
5 初始化列表
	class 类名{
		类名(参数表):成员变量(初值),...{}
	};
1）以有参的方式初始化成员子对象，必须使用初始化列表
2）类中有“const”或“引用”成员变量，必须使用初始化列表
3）成员变量的初始化顺序由声明顺序决定，而与初始化列表的顺序无关，所以不要使用一个成员变量初始化另一个成员变量.


十五 this指针和常成员函数
1 this指针
1）类中成员函数(包含构造函数、析构函数)都隐藏一个当前类类型的指针参数，名为this，在成员函数中访问类中的其它成员，本质都是this指针来实现的:
--》对于普通成员函数，this指向调用对象的地址
--》对于构造函数，this指向正在创建的对象地址
	
2）多数情况，使用this指针显式访问类中成员和直接访问没有区别，但是以下的场景必须使用this指针：
--》区分作用域
--》从成员函数返回调用对象自身//重点掌握
--》从类的内部销毁对象自身
--》作为成员函数的实参，实现对象之间的交互//了解	
	
2 常成员函数(常函数)
1）在成员函数参数表后面加上const修饰，即为常成员函数
   返回类型 函数名(参数表) const {函数体}
2）常成员中的this指针是一个常指针，不能在常成员函数中直接修改成员变量的值.
  注：被mutable关键字修饰的成员变量，可以在常函数中直接修改.
3）非const对象既可以调用常函数也可以调用非常函数；但是常对象只能调用常函数，不能调用非常函数//重点掌握
  注：常对象也包括常指针和常引用
4）同一个类中，函数名和参数表相同的成员函数，其常版本和非常版本可以构成重载关系，常对象匹配常版本，非常对象匹配非常版本.

十六 析构函数(Destructor)
1 语法
	class 类名{
		~类名(void){
			//主要负责清理对象生命周期中的动态资源
		}
	};
	1）函数名必须是"~类名"
	2）没有返回类型，也没有参数
	3）析构函数不能被重载，一个类只能有一个析构函数
	
2 当对象被销毁时，该类的析构函数将自动被执行
1）栈对象离开所在作用域时，其析构函数被作用域终止的右花括号"}"自动调用.
2）堆对象的析构函数被delete操作符自动调用.
注：delete对象时，首先会调用析构函数，清理对象所维护的动态资源，再销毁对象自身内存；而如果是free仅能销毁对象自身的内存，不会调用析构函数.

3 如果类中自己没有显式定义析构函数，那么编译器会为该类提供一个缺省的析构函数：
--》对于基本类型成员变量什么也不做
--》对类 类型的成员变量(成员子对象),将会自动调用相应类的析构函数。

4 对象的创建和销毁过程
1）创建
--》分配内存
--》构造成员子对象(按声明顺序)
--》执行构造函数代码

2）销毁
--》执行析构函数代码
--》析构成员子对象(按声明逆序)
--》释放内存

项目：企业员工管理系统V3.0
需求：优化企业员工类
  1）构造函数改用初始化列表方式
  2）将打印信息函数声明为常成员函数
  3）创建员工对象时，将员工信息保存到文件中，文件名和工号一致。
  
提示：
	class Employee{
		构造函数(...):...{
			m_id(int)-->"m_id"(char*)//sprintf
			file = fopen("m_id","w");
			fprintf(...)
		}
		析构函数(void){
			fclose(file);
		}
		FILE* file;
	}；



回顾：
1 this指针
1）区分作用域
2）返回自引用，return *this;
3）对象自销毁，delete this;
4）作为成员函数实参，实现对象交互

2 常成员函数
1）const修饰的成员函数
2）不能在常函数不能修改成员变量，mutable
3）常对象只能调用常函数
4）函数名和形参表相同的成员函数，常版本和非常版本可以重载；

3 析构函数(Destructor)
  ~类名(void){清理对象的动态资源}

4 对象的创建和销毁
创建：分配内存->构造子对象->构造函数代码
销毁：析构函数代码->析构子对象->释放内存
--------------------------------
今天：
十七 拷贝构造和拷贝赋值
1 浅拷贝和深拷贝//参考copy1.png
1）如果类中包含了指针形式的成员变量，缺省的拷贝构造函数只是复制了指针变量本身，而没有复制指针所指向的数据，这种拷贝方式被称为浅拷贝
2）浅拷贝将会导致 不同对象的数据共享，同时可能会在析构时引发"double free"的异常，因此就必须自定义一个支持复制指针所指向数据的拷贝构造函数,即深拷贝.

2 拷贝赋值//参数copy2.png
1）当两个对象进行赋值操作时，比如“i2=i3”,编译器会自动将其翻译成i2.operator=(i3)成员函数调用形式，其中“operator=”被称为拷贝赋值操作符函数，由该函数实现两个对象的赋值运算，其返回结果就是表达式结果.
2）如果自己没有定义拷贝赋值函数，那么编译器会为该类提供一个缺省的拷贝赋值函数，但是缺省的拷贝赋值和拷贝构造类似，也是浅拷贝，有“double free”、数据共享、内存泄漏等问题，为了避免这些问题，需要自定义深拷贝赋值函数：
	类名& operator=(const 类名& that){
		if(&that != this){//防止自赋值
			//释放旧内存
			//分配新内存
			//拷贝新数据
		}
		return *this;//返回自引用
	}
	注：this指向左操作数，that对应右操作数

练习：实现String类，里面包含构造函数、析构函数、拷贝构造、拷贝赋值。

十八 静态成员(static)
1 静态成员变量
class 类名{
	static 数据类型 变量名;//声明
};
数据类型 类名::变量名 = 初值;//定义和初始化
1）普通成员变量属于对象，而静态成员变量不属于对象
2）普通成员变量在对象构造时定义和初始化，而静态成员变量需要在类的外部单独定义和初始化。
3）静态成员变量和全局变量类似，被存放在数据段，可以把静态成员变量理解为被限制在类中使用的共享资源.
4）使用
	类名::静态成员变量;//推荐
	对象.静态成员变量;//本质和上面等价

注：如果有const修饰的静态成员变量，可以在声明时初始化(特殊，了解)

2 静态成员函数
class 类名{
	static 返回类型 函数名(参数表){...}
};
1）静态成员函数没有this指针，也没有const属性
2）可以把静态成员函数理解为被限制在类中使用的全局函数
3）使用：
   类名::静态成员函数(实参表);//推荐
   对象.静态成员函数(实参表);//本质和上面等价
注：在静态成员函数中只能访问静态成员，而非静态成员函数中既可以访问静态成员也可以访问非静态的成员. 
   
3 单例模式
1）概念：
   一个类只允许存在唯一的对象，并提供它的访问方法
   
2）实现思路：
--》禁止在类的外部创建对象：私有化构造函数
--》类的内部维护唯一的对象：静态成员变量
--》提供单例对象的访问方法：静态成员函数

3）创建方式：
--》饿汉式：单例对象无论用或不用，程序启动即创建
--》懒汉式：单例对象用时再创建，不用即销毁

十九 成员指针//了解
1 成员变量指针
1）定义
	类型 类名::* 成员指针变量名 = &类名::成员变量;
2）使用
	对象.*成员指针变量名;
	对象指针->*成员指针变量名;

	注:".*"直接成员指针解引用操作符
	   "->*"间接成员指针解引用操作符

2 成员函数指针
1）定义
	返回类型 (类名::*成员函数指针)(参数表) 
		= &类名::成员函数名;
2）使用
	(对象.*成员函数指针)(实参表);
	(对象指针->*成员函数指针)(实参表);
	
	
练习：复习前面内容，重点看“十 引用”,“十五 this常成员函数”。

项目：企业员工管理系统V4.0
需求：优化企业员工类
	1）禁用拷贝构造和拷贝赋值
	2）创建对象时，从指定文件获取工号，保证工号唯一
	   id.txt-->m_id-->id.txt(+1)
	3）增加静态成员变量记录员工人数，人数信息保存到文件中。
	4）增加静态成员函数，获取员工人数信息

回顾：
1 拷贝构造和拷贝赋值
1 浅拷贝和深拷贝
2 拷贝赋值函数
  i1 = i2;//i1.operator=(i2)

2 静态成员(static)
1）静态成员变量，数据段(全局区)
2）静态成员函数，没有this指针
3）使用静态成员“类名::静态成员”

3 单例模式
1）私有化构造函数
2）静态成员变量维护唯一的对象
3）静态成员函数获取单例对象
4）实现方式：饿汉式和懒汉式

4 成员指针//了解

======================
今天：
二十 操作符重载
1 基本概念
  所谓的操作符重载就是一些具有特殊名字的函数，"operator 连接需要重载某个操作符",比如"operator="、"operator+"...,通过这样特殊的函数，把已定义的操作符重新定义，完成程序员想要的运算功能.

eg:复数(x+yi)
   (1+2i) + (3+4i) = 4+6i;
   
1 双目操作符重载 L#R
1.1 计算类双目操作符：+ - ...
--》左右操作数既可以是左值也可以是右值
--》表达式结果是右值，禁止对表达式结果再赋值
--》两种实现方式
  1）成员函数形式（左调右参）
  形如L#R表达式将会被编译器自动处理为L.operator#(R)的成员函数调用形式，由该函数完成运算功能，函数的返回结果就是表达式结果.
  L#R ==> L.operator#(R)
  
  2）全局函数形式(左右操作数都为参数)
  形如L#R表达式也可被编译器自动处理为operator#(L,R)的全局函数调用形式，由该函数完成运算功能，函数的返回结果就是表达式结果.
  L#R ==> operator#(L,R)
   
  注：通过friend关键字，可以把一个全局函数声明为某个类的友元，友元函数可以访问类中的任何成员。

1.2 赋值类双目操作符：+= -= ...
--》左操作数必须是左值，右操作数可以左值也可以是右值
--》表示式结果是左值，就是左操作数自身
--》两种实现方式
  1）成员函数形式：L#R ==> L.operator#(R)
  2）全局函数形式：L#R ==> operator#(L,R)
  
2 单目操作符的重载 #O
2.1 计算类单目操作符：~ -(取负) !...
--》操作数可以是左值也可以是右值
--》表达式结果是右值，禁止对表达式结果在赋值
--》两种实现方式
  1）成员函数形式：#O ==> O.operator#();
  2）全局函数形式：#O ==> operator#(O);

2.2 自增减单目操作符：++、--
1）前++、--
--》操作数一定是左值
--》表达式结果也只左值，就是操作数自身
  成员函数形式：#O ==> O.operator#();
  全局函数形式：#O ==> operator#(O);
  
2）后++、--
--》操作数一定是左值
--》表达式结果是右值，是操作数自增减前副本.
  成员函数形式：O# ==> O.operator#(int/*哑元*/);
  全局函数形式：O# ==> operator#(O,int/*哑元*/);
  
3 输出(插入)和输入(提取)操作符重载：<< >>
功能：实现自定义类型对象的直接输出或输入
注：只能使用全局函数形式(friend)

  #include <iostream>
  ostream //标准库中表示标准输出流类
  istream //标准库中表示标准输入流类
  
  ostream& operator<<(ostream& os,const RIGHT& r){
      //...
  		return os;
  }
  istream& operator<<(istream& is,RIGHT& r){
      //...
  		return is;
  }
  
  //全局函数：operator<<(cout,a)
  cout << a << b << c <<..;
  //全局函数：operator>>(cin,a)
  cin >> a;
 
4 下标操作符: []
功能：实现自定义类型的对象像数组一样使用
注：常对象返回右值，非常对象返回左值
  string s = "hello";
  s[0] = 'H'; //ok,s.operator[](0)
  const string& cs = s;
  cs[0] = 'H';//error,cs.operator[](0)
  
5 函数操作符：()
功能：实现自定义类型的对象像函数一样使用(仿函数)
注：对参数个数、参数类型和返回值类型没有任何限制
	class A{};
	A a;
	a(100,1.23);//a.operator()(100,1.23)

6 new/detele操作符
  static void* operator new(size_t size){...}
  static void operator delete(void* pv){...}
 
7 操作符重载的限制
1）不是所有符号都能重载，下列操作符不允许重载
--》作用域限定操作符 “::”
--》直接成员访问操作符 “.”
--》直接成员指针解引用操作符 ".*"
--》条件操作符 "?:"
--》字节长度操作符 "sizeof" 
--》类型信息操作符 "typeid"//后面讲
2）如果重载的操作符所有操作数都是基本类型，则无法被重载.
3）操作符重载不会改变预定义的优先级
4）操作符重载后无法改变操作数个数
5）无法通过操作符重载机制发明新的符号
6）只能使用成员函数形式重载的操作符： = () [] ->

项目：企业员工管理系统V5.0
需求：优化企业员工类
1）增加输出操作符重载
   friend ostream& operator<<(
   	ostream& os,const Employee& emp){}
   cout << emp << endl;
   
2）增加比较操作符重载：== !=
	bool operator==(int id)const{}
	bool operator!=(int id)const{}

	Employee emp(10001,...);
	if(emp == 10001){}//emp.opeartor==(10001)
	if(emp != 10001){}

练习：实现一个3*3矩阵类，支持如下操作符重载
	   + - += -= -(负) 前后++、-- <<
	   * *=
提示：
	class M33{
	public:
		M33(void){
			for(int i=0;i<3;i++)
				for(int j=0;j<3;j++)
					m_a[i][j] = 0;
		}
		M33(int a[][3]){
			for(int i=0;i<3;i++)
				for(int j=0;j<3;j++)
					m_a[i][j] = a[i][j];
		}
	private:
		int m_a[3][3];
	};
	int a1[3][3] = {1,2,3,4,5,6,7,8,9};
	int a2[3][3] = {9,8,7,6,5,4,3,2,1};
	M33 m1(a1);
	M33 m2(a2);
	m1+m2 ==> m1.operator+(m2)
	1 2 3		9 8 7		10 10 10
	4 5 6	+	6 5 4	 = 10 10 10
	7 8 9		3 2 1		10 10 10
	m1-m2 ==> m1.operator-(m2)
	1 2 3		9 8 7		-8 -6 -4
	4 5 6	-	6 5 4	 = -2  0  2
	7 8 9		3 2 1		 4  6  4
	m1*m2 ==> m1.operator*(m2)
	1 2 3		9 8 7		30  24  18
	4 5 6	*	6 5 4	 = 84  69  54
	7 8 9		3 2 1		138 114 90
	二十一 继承(Inheritance)
1 继承的概念//了解
  通过一种机制表达类型之间共性和特性的方式，利用已有数据类型定义新的数据类型,这种机制就是继承.
eg:
	人类：姓名、年龄、吃饭、睡觉
	学生类：姓名、年龄、吃饭、睡觉、学号、学习
	教师类：姓名、年龄、吃饭、睡觉、工资、讲课 
	... 
   -------------------------------
   人类：姓名、年龄、吃饭、睡觉
   学生类继承人类：学号、学习
   教师类继承人类：工资、讲课
   ...
   
   	人类(基类/父类)
     /	 \
   学生   教师(子类/派生类)
   
   基类--派生--》子类
   子类--继承--》基类
   
2 继承语法
	class 子类:继承方式 基类1,继承方式 基类2,...{
	};
	继承方式:
	1）public:公有继承
	2）protected:保护继承
	3）private:私有继承

3 公有继承的语法特性
1）子类对象会继承基类的属性和行为，通过子类对象可以访问基类中的成员，好像是基类对象在访问它们一样。
  注：子类对象中包含的基类部分可以称为“基类子对象”

2）向上造型(upcast)//重点掌握
   将子类类型的指针或引用转换为基类类型的指针或引用，这种操作性缩小的类型转换，在编译器看来是安全，可以直接隐式转换.
  基类
   ↑
  子类
	class A{};//基类
	class B:public A{};//子类
	class C:public A{};//子类
	class D:public A{};//子类
	void func(A* pa){}
	int main(void){
		A a; func(&a);
		B b; func(&b);//向上造型
		C c; func(&c);//向上造型
		...
	}
	
3）向下造型(downcast)
   将基类类型的指针或引用转换为子类类型的指针或引用，这种操作性放大的类型转换，在编译器看来是危险的，不能隐式转化，可以显式转换(推荐static_cast).
  基类
   ↓
  子类

4）子类继承基类的成员
--》在子类中，可以直接访问基类中的公有或保护成员，就好像它们被声明在子类一样.
--》基类中的私有成员，子类也可以继承，但是会受到访问控制属性的限制，无法直接访问。但是可以让基类提供公有或保护的接口函数，来间接访问。

5）子类隐藏基类的成员
-->如果子类和基类中定义了同名的成员函数，因为作用域不同不能构成重载关系，而是隐藏关系.
-->如果需要通过子类访问基类中被隐藏的成员，可以借助“类名::”显式指明//推荐
-->也可以通过using声明将基类中的成员函数引入到子类作用域，让它们在子类形成重载，通过参数重载解析解决

4 访问控制属性和继承方式
1）访问控制属性：影响访问该类成员的位置
访问控制		访问控制		内部	子类	外部	友元
限定符		属性			访问	访问	访问	访问
public		公有成员		ok		ok		ok		ok
protected	保护成员		ok		ok		no		ok
private		私有成员		ok		no		no		ok
2）继承方式：影响通过子类访问基类中成员的可访问性
基类中成员	公有继承子类  保护继承子类 私有继承子类
公有成员		公有成员			保护成员   	私有成员
保护成员		保护成员			保护成员		私有成员
私有成员		私有成员			私有成员		私有成员
注：向上造型语法特性在保护继承和私有继承中不再适用

5 子类构造函数
1）如果子类的构造函数没有指明基类子对象的初始化方式，将会自动选择基类的无参构造函数来初始化。
2）如果希望基类子对象以有参的方式被初始化，则必须使用初始化列表来显式指明.
3）子类对象创建的过程
--》分配内存
--》构造基类子对象(按继承表从左到右顺序)
--》构造成员子对象(按声明自上而下顺序)
--》执行子类构造函数代码
6 子类的析构函数
1）子类的析构函数，无论定义还是缺省的，都会自动调用基类的析构函数，完成基类子对象的销毁操作。
2）子类对象的销毁过程
--》执行子类析构函数代码
--》析构成员子对象(按声明逆序)
--》析构基类子对象(按继承表逆序)
--》释放内存
3）基类的析构函数不会自动调用子类析构函数，所以如果delete一个指向子类对象的基类指针，实际被执行的仅是基类的析构函数，子类的析构函数执行不到，有内存泄漏的风险！
	class A{};
	class B:public A{};
	A* pa = new B;//pa:指向子类对象的基类指针
	delete pa;//仅执行基类的析构函数，有内存泄漏风险

7 子类的拷贝构造和拷贝赋值
1）子类的拷贝构造
--》如果子类没有定义拷贝构造函数，那么编译器会为子类提供缺省的拷贝构造函数，它自动调用基类的拷贝构造函数，完成基类子对象的拷贝操作。
--》如果自定义了拷贝构造函数，编译器不再为子类提供缺省的拷贝构造，这时需要使用初始化列表，显式指明基类子对象也要以拷贝的方式进行初始化.
   class Base{};
   class Derived:public Base{
   	//Base(that):指明基类子对象以拷贝方式初始化
   	Derived(const Derived& that):Base(that),...{}
   };
2）子类的拷贝赋值
--》如果子类没有自己定义拷贝赋值函数，那么编译器会为子类提供一个缺省的拷贝赋值函数，该函数会自动调用基类的拷贝赋值函数，完成基类子对象的拷贝操作。
--》如果子类自己定了拷贝赋值函数，那么编译器不再为子类提供缺省的拷贝赋值函数，这时需要显式的调用基类的拷贝赋值函数，完成基类子对象的拷贝操作.
	class Base{};
   class Derived:public Base{
   	Derived& operator=(const Derived& that){
   		if(&that != this){
   			//显式的调用基类的拷贝赋值函数
   			Base::operator=(that);
   			...
   		}
   		return *this;
   	}
   };
   
   
项目：企业员工管理系统V6.0
需求：增加技术员类和经理类
		 员工类(Employee)
		/		 \
	技术员  	  经理
	
	1）技术员：
		研发津贴(元/小时)
	   绩效工资=实际工作小时*研发津贴*进度因数(输入)
	2）经理：
		绩效奖金(元/小时)
		绩效工资=绩效奖金*绩效因数(输入)


昨天回顾
1 集成概念
2 继承语法
 class 子类:继承方式 基类1,继承方式 基类2...{};
 继承方式:public protected private
3 共有继承特性
 1)可以子类对象看做是基类对象
  基类子对象:子类对象中包含的基类部分
 2)向上造型:把子类指针,引用-->基类指针,引用
 3)向下造型:基类指针,引用-->子类指针,引用
 4)子类继承基类的成员:公有,保护和私有
 5)子类隐藏基类的成员:"解决 "类名::"

 4 访问控制属性和继承方式
 
 5 子类的构造函数
 1)没有指明基类子对象初始化方式,自动选择无参方式
 2)可以通过初始化列表指明基类子对象的初始化方式
 3)子类对象创建过程
 -->分配内存
 -->构造基类子对象
 -->构造成员子对象
 -->执行子类构造代码

6 子类系够函数
1) 子类的基类会自动调用基类的系够函数
2)子类对象销毁过程
-->执行子类系够函数代码
-->系够成员子对象
-->系够基类子对象
-->释放内存

7 子类拷贝构造和拷贝赋值

 _______________________________________________
 
 今天内容:
 二十一 继承(Inheritance)
 .....
 8 多重继承
 1)概念
 一个子类同时继承多个基类,这样的继承方式被称为多重继承
 2)向上造型时,编译器会根据各个基类子对象的内存布局,自动进行计算,保证指针的类型和所指向的目标子对象类型一致 
 3)名字冲突问题
 -->多重继承时,如果多个基类中存在相关的名字,通过子类访问时,编译器将会报歧义错误--名字冲突
  


 9 钻石继承和虚继承
 1)一个子类的多个基类同时继承共同的基类祖先,这样的继承结果称为钻石继承

     A
    / \
   B   C
    \ /
     D
	
注
2)创建末端子类D对象时,会包含多个公共基类(A)子对象,通过末端子类访问共共基类的成员,会因为继承路径不同而导致结果不一致.
3)通过虚继承可以让公共基类(A)子对象在末端子类(D)对象中实例唯一,并且可以为所有的中间(B,C)类共享,这样即使沿着不同的继承路径,所访问到的公共成员也是一致的
4)虚继承语法
 -->在继承表使用virtual 关键字修饰
 -->位于继承连的末端子类负责构造公共基类子对象

_______________________________________________________________
 二十二  多态(polymorphic)

 1 虚函数覆盖(函数重写),多态的概念
 1)如果将基类中某个成员函数声明为虚函数,那么子类中具有与相同原型的成员函数就也会变成虚函数,并且对基类中的版本形成覆盖,即函数重写
 2)满足了虚函数覆盖,在通过指向子类对象的基类指针或引用子类对象的基本引用,调用虚函数,实际被执行的将是子类中的覆盖版本,而不再是基类中原始版本.这种语法现象被称为多态
 
 2 虚函数覆盖的条件
 1)只有类中成员函数才能声明为虚函数,而静态成员函数,构造函数和全局函数都不能为虚函数 (析构函数可以是虚函数 后面讲)
 2)虚函数virtual 关键字修饰必须卸载基类中,而与子类中的virtual 无关
 3)虚函数在子类中版本和基类中版本必须具有相同的函数签名 即函数名,参数表,常属性一致
 4)如果虚函数在基类中版本返回基本类型的数据,那么子类中覆盖版本必须返回相同类型的数据
 5)如果虚函数在基类中版本返回类型的指针(A*)或引用(A&),那么允许子类中覆盖版本返回其子类型的指针(B*)或引用(V&)
 
 
 3多态的条件
1)多态的语法特性除了需要满足虚函数条件覆盖条件,还必须通过指针或引用调用虚函数,才能表现出来.
2)调用函数的指针也可以是this指针,当通过子类对象调用基类中的成员函数时,该成员函数中的this指针将是一个指向子类对象的基类指针,
在通过他调用虚函数,同样可以表现多态的语法特性 // 重点掌握

4 关于多态的实现原理 //了解
   多态 通过虚函数表和动态绑定来实现
 1)虚函数表的生成会增加内存的开销
 2)动态绑定的过程或增加时间效率
 3)虚函数不能被内联优化
 注:如果没有多态的语法要求,最好不要使用虚函数

项目扩展练习v7.0
需求: 增加技术主管类
1)同时具备技术员的研发津贴和经理绩效奖金
2)绩效工资=(技术员绩效+经理绩效)/2

项目扩展练习 v8.0
需求: 使用多态语法优化继承结构

回顾:
1 多重继承
1)一个子类同时继承多个基类
2)向上造型,自动偏移计算
3)名字冲突问题. 解决 "类名::"

2 钻石继承和虚继承
      A
    /   \
    B   C
    \   /
      D

3 多态
1)基本概念
2)虚函数覆盖条件
3)多态条件,通过指针(this)或引用调用虚函数
4)多态原理:虚函数表和动态绑定
 
______________________________________________________

 今天

 二十二	 多态

 5 纯虚函数,抽象类和纯抽象类
 1)纯虚函数
  virtual 返回类型  函数名(形参表)=0;
 2)抽象类
  如果类中成员函数有纯虚函数,那么该类就是抽象类
  注:抽象类不能创建对象;
 3)纯抽象类
  如果类中所有的成员函数都是纯虚函数,那么该类就是纯抽象类.

 6 虚析构函数
  1)基类的析构函数不会自动的调用子类析构函数,所以如果delete 一个指向子类对象的基类指针,实际被执行的仅是积累的析构函数 
 
  2)如果将基类的析构函数生命为虚函数(虚析构函数),这时子类的析构函数也是虚函数,并且可以对基类的徐析构函数

今天：
二十三 运行时类型信息 //了解
1 typeid操作符
  #include <typeinfo>
  typeid(类型/对象),返回typeinfo对象用于描述类型信息
  注：typeinfo类中包含name成员函数，可以获取字符串形式的类型信息。
  注：typeinfo类中支持“==”“!=”操作符,通过它们可以直接进行类型之间的比较，如果类型之间具有多态的继承关系，typeid还可以利用多态语法确定实际的目标对象类型.
  
2 dynamic_cast操作符
语法:
	目标变量 = dynamic_cast<目标类型>(源类型变量);
适用场景：
	主要用于具有多态继承关系，指针或引用的显式转换
	注：在转换过程中，会检查目标变量类型和期望转换的类型是否一致，如果一致则转换成功，如果不一致则失败，如果转换指针返回NULL表示失败，如果转换是引用，抛出异常“bad_cast”表示失败。
	
二十四 C++异常机制
1 软件开发中常见错误
1）语法错误
2）逻辑错误
3）功能错误
4）设计缺陷
5）需求不符
6）环境异常
7）操作不当

2 传统C中的错误处理机制
1）通过返回值表示错误
优点：函数调用路径中所有的栈对象都可以得到正确析构，不会内存泄漏。
缺点：错误处理流程比较麻烦，需要对函数调用路径逐层进行返回值判断，代码臃肿。

2）通过远程跳转处理错误
优点：不需要进行逐层返回值判断，实现一步到位错误处理，代码精炼。
缺点：函数调用路径中的栈对象失去被析构机会，有内存泄漏的风险。

3 C++异常语法
1）异常抛出
   throw 异常对象;
   注：异常对象可以基本类型，也可以是类类型
2）异常检测和捕获
	try{
		//可能引发异常语句
	}
	catch(异常类型1){
		针对异常类型1的处理
	}
	catch(异常类型2){
		针对异常类型2的处理
	}
	...
   注：catch子句根据异常对象类型自上而下顺序匹配，而非最优匹配。因此对子类类型异常捕获语句要写在前面，不能写在对基类类型异常捕获语句后面，否则将会被基类类型的异常捕获语句提前截获。
   
4 函数的异常说明
1)用于说明函数可能抛出的异常类型
  返回类型 函数名(形参表) throw(异常类型表) {函数体}
2)函数的异常说明是一种承诺，表示该函数所抛出的异常不会超出说明的范围，如果函数的实现者抛出了异常说明以外的类型，是无法被函数调用者正常捕获，而会被系统捕获，导致进程终止。
3)两种极端形式
--》不写异常说明，表示可以抛出任何异常
--》空异常说明,"throw()"表示不会抛出任何异常
4)如果函数的声明和定义分开写时，要保证异常说明类型一致，但是顺序无所谓.
//补充虚函数覆盖条件：
5)如果基类中的虚函数带有异常说明，那么该函数在子类中的覆盖版本不能说明比基类版本抛出更多的异常，否则将会因为"放松throw限定"导致编译失败.

5 标准异常类：exception
 class exception{//标准C++库
 public:
    exception() throw() {} 
    virtual ~exception() throw() ;

    /*Returns a C-style character string describing 
      the general cause of the current error.  */
    virtual const char* what() const throw();
 };

6 构造和析构函数的异常//了解
1）构造函数可以抛出异常，但是对象将被不完整创建，这样对象的析构不再会自动被执行，因此在构造函数抛出异常之前，需要手动释放之前分配的动态资源.
2）析构函数最好不要抛出异常


二十五 I/O流 //了解
1 主要的I/O流类
							ios
					/					\
				istream				ostream
		/		 |			\    /      |		\
istrstream ifstream iostream	ofstream  ostrstream

2 格式化I/O
1）格式化函数(成员函数)
	cout << 20/3.0 << endl;//6.66666
   cout.precision(10);
   cout << 20/3.0 << endl;//6.666666666

2）流控制符(全局函数)
	cout << 20/3.0 << endl;//6.66666
   cout << setprecision(10) << 20/3.0 <<
   	 endl;//6.666666666
 
3 字符串I/O
#include <strstream>//过时，不要使用
istrstream/ostrstream

#include <sstream>//推荐
istringstream //类似sscanf()
ostringstream //类似sprintf()

4 文件I/O
#include <fstream>
ifstream //类似fscanf();
ofstream //类似fprintf();

5 二进制I/O
//类似fread
istream& istream::read(char* buf,streamsize num);
//类似fwrite
ostream& ostream::write(const char* buf,size_t num);

















 












































































 

	



