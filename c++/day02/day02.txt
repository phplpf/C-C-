回顾：
1 C++语言概述：C++98、C++11/C++0x
2 第一个C++程序
1）g++ xx.cpp、gcc xx.cpp -lstdc++
2）.cpp
3）头文件：iostream、cstdio
4）cout、cin
3 名字空间(namespace)
1）定义
   namespace 空间名{名字空间成员;...}
2）名字空间成员使用
--》空间名::成员;
--》名字空间指令,using namespace std;
--》名字空间声明,using 空间名::成员;
3）全局作用域和无名空间，"::成员"
4）名字空间嵌套

4 C++结构体、联合体和枚举

5 C++字符串：string
1）定义: string s="xx";
2）操作：= +/+= ==/!=/>/</>=/<= []
3）成员函数：size()/length()  c_str()

-----------------------------
今天：
六 C++的布尔类型：bool
1 bool类型是C++中基本数据类型，专门表示逻辑值，逻辑真为true，逻辑假为false
2 bool类型在内存占一个字节：1表示true，0表示false
3 bool类型变量可以接收任意类型表达式的结果，数值非零则为真，为零则为假。
	bool isEmpty(void){
		...
		return true/false;
	}

七 操作符别名//了解
	&& <==> and
	|| <==> or
	^  <==> xor
	{	<==> <%
	}  <==> %>
	...
	
八 C++的函数
1 函数重载(overload)
1）定义
	在相同作用域，可以定义同名的函数，但是它们的参数必须有所区分，这样的函数关系称为函数重载.
	注：函数重载和返回类型无关.
	
eg:图形库中绘图函数
	void drawRect(int x,int y,int w,int h){...}
	void drawCircle(int x,int y,int r){...}
	...
	------------------------------------------
	void draw(int x,int y,int w,int h){...}
	void draw(int x,int y,int r){...}
	...
2）函数重载匹配
   调用函数时，编译器根据实参和形参匹配程度，自动选择最好的重载版本.
  当前g++编译器匹配的优先级：
  完全匹配>=常量转换>升级转换>降级转换>省略号匹配
3）函数重载原理
	C++的编译器是通过函数换名，将参数表的类型信息整合到新的函数名中，实现解决函数重载和名字冲突的矛盾。  
	笔试题：C++中extern "C"声明作用？
	可以在函数声明前面加入 extern "C"，要求C++编译器不要对该函数进行换名，便于C程序直接调用。
	注：被extern "C"声明的函数无法重载

2 函数的哑元参数
1）定义
	定义函数时,只有类型而没有变量名形参被称为哑元.
	void func(int/*哑元*/){...}
2）使用哑元场景
--》操作符重载，通过哑元区分前后++/--(后面讲)
--》兼容旧代码
eg:
	//算法库：
	void math_func(int a,int b){...}
	//使用者
	int main(void){
		math_func(10,20);
		...
		math_func(30,40);
	}
	=========================================
	//算法库升级：
	void math_func(int a,int/*哑元*/){...}
	//使用者
	int main(void){
		math_func(10,20);
		...
		math_func(30,40);
	}

3 函数的缺省参数(默认实参)
1）可以为函数的参数指定缺省值，调用该函数时，如果不给实参，就会取缺省值作为默认实参.
	void func(int a,int b=0/*缺省参数*/){...}
2）靠右原则，如果函数的某个参数有缺省值，那么该参数右侧的所有参数都必须带有缺省值.
3）如果函数声明和定义分开写，缺省参数应该写在函数的声明部分，而定义部分不写.
	void func(...);//函数声明
	void func(...){...}//函数定义
	
4 内联函数(inline)
1）使用inline关键字修饰的函数即为内联函数，编译器将会尝试进行内联优化，可以避免函数的调用开销，提高代码执行效率.
	inline void func(void){...}
2）使用说明
--》多次调用的小而简单的函数适合内联
--》调用次数极少或者大而复杂的函数不适合内联
--》递归函数不能内联
--》虚函数不能内联(后面讲)
注：内联优化只是一种建议而不是强制要求，一个函数能否内联优化主要取决于编译器，有些函数不加inline修饰也会默认处理为内联优化,有些函数即便加了inline修饰也会被编译器忽略掉.

九 C++的动态内存管理
1 回顾C中动态内存管理
1）分配：malloc()
2）释放：free()

2 C++的动态内存管理
1）分配：new、new[]
2）释放：delete、delete[]

十 C++的引用(Reference)
1 定义
1）引用即别名，就是某个变量的别名，对别名操作和对变量本身操作完全相同.
2）语法
	类型 & 引用名 = 变量名;
	注：定义引用时必须初始化，初始化以后绑定的目标变量不能再修改。
	注：引用的类型和绑定目标变量类型一致。
eg：
	int a = 100;
	int & b = a;//b就是a的别名
	b++;
	cout << a << endl;//101

2 常引用
1）定义引用时加const修饰，即为常引用，不能通过常引用修改目标变量.
	const 类型 & 引用名 = 变量名;
	类型 const & 引用名 = 变量名;//和上面完全等价
eg:
	int a = 100;
	const int& b = a;//b就是a的常引用
	b++;//error

2）普通的引用也可以称为左值引用，只能引用左值不能引用右值；而常引用也可以称为万能引用，既可以引用左值也可以引用右值。

注：关于左值和右值
左值(lvalue):可以放在赋值操作符左侧，可以被修改
右值(rvalue):只能放在赋值操作符右侧，不能被修改

练习：测试下面运算表达式，哪个结果是左值或右值？
	int a = 3 , b = 5;
	a + b;
	a += b;
	++a;
	a++;
	 

		