回顾：
1 布尔类型bool
2 操作符别名
3 C++的函数
1）函数重载，extern "C"
2）哑元参数，void func(int/*哑元*/){..}
3）缺省参数，void func(int a,int b=0){..}
4）内联函数，inline void func(void){..}

4 C++动态内存管理
1）分配：new/new[]
2）释放：delete/delete[]

5 引用(Reference)
1）引用即别名
2）定义： 类型 & 引用名 = 变量名;
3）常引用(万能引用)
	const 类型 & 引用名 = 变量名;	
4）关于左值(lvalue)和右值(rvalue)
	int a = 3,b = 5;
	int& r1 = a+b;//no
	int& r2 = ++a;//ok
	int& r3 = a++;//no
	int& r4 = (a+=b);//ok
	
---------------------------------
今天:
十 C++的引用(Reference)	
...
3 引用型函数参数
1）可以将 引用用于函数参数，这时形参就是实参的别名，可以通过形参直接修改实参，同时传递引用型参数可以避免参数值传递的过程，减小函数调用的开销，提高代码执行效率.
2）引用型参数有时可能会意外的修改实参值，如果传递引用型参数仅是为了提高传参效率，不想修改实参值，可以附加const修饰，将参数定义为常引用，提高传参效率的同时还可以接收常量型的实参.

4 引用型函数返回值
1）可以将 引用用于函数的返回值，这时函数返回结果就是return后面数据的别名，可以避免返回值的开销，提高代码的效率.
2）如果函数返回数值是左值引用，那么函数调用表达式结果就也是左值.

注：不要从函数中返回局部变量的引用，因为所引用的目标变量内存会在函数返回以后被释放，使用危险！可以从函数中返回成员变量、静态变量、全局变量的引用.

5 引用和指针
1）从C角度看待引用，其本质就是指针，但是C++开发中推荐使用引用而不是指针
	int i = 100;
	int* const pi = &i;
	int& ri = i;	
	*pi <==> ri 
2）指针定义时可以不做初始化，指针的目标也可以修改(指针常量除外);而引用在定义时必须初始化，而且初始化以后其目标不能再修改.
	int a = 3,b = 5;
	int* p;//ok
	p = &a;//p指向a的地址
	p = &b;//p指向b的地址
	-------------------
	int& r;//error
	int& r = a;
	r = b;//不是修改目标，仅是赋值操作

//往下了解：
3）可以定义指针的指针(二级指针)，但是不能定义引用的指针.
	int a = 10;
	int* p = &a;
	int** pp = &p;//ok,二级指针
	---------------------------
	int& r = a;
	int&* pr	= &r;//error,引用的指针
	int* pr = &r;//ok,但就是普通指针
	
4）可以定义指针的引用(指针变量的别名)，但是不能定义引用的引用
	int a = 10;
	int* p = &a;
	int*& rp = p;//ok,指针的引用
	------------------------------
	int& r = a;
	int&& rr = r;//error,引用的引用
	int& rr = r;//ok,但就是普通引用

5）可以定义指针数组，但是不能定义引用数组，可以定义数组引用(数组的别名)
	int a=10,b=20,c=30;
	int* parr[3] = {&a,&b,&c};//ok,指针数组
	int& rarr[3] = {a,b,c};//error,引用数组
	-------------------
	int arr[3] = {a,b,c};
	int (&rarr)[3] = arr;//ok,数组引用
6）可以定义函数指针，也可以定义函数引用(函数的别名)，语法特性一致。
	void func(int i,double d){...}
	int main(void){
		void (*pfunc)(int,double) = func;//函数指针
		void (&rfunc)(int,double) = func;//函数引用
		pfunc(10,1.23);
		rfunc(10,1.23);
		return 0;
	}

十一 类型转换
1 隐式类型转换
  char c = 'q';
  int i = c;//隐式
  -----------------
  void func(int i){}
  func(c);//隐式
  -----------------
  int func(void){
  		return c;//隐式
  }

2 显式类型转换
1）C++中兼容C中强制转换
  char c = 'q';
  int i = (int)c;//C风格
  int i = int(c);//C++风格，本质和上面一样

2）C++扩展的四种操作符形式的显式转换
--》静态类型转换
语法：
	目标变量 = static_cast<目标类型>(源类型变量);
适用场景：
	用于将void*转换为其它类型指针.
--》动态类型转换(后面讲)
语法：
	目标变量 = dynamic_cast<目标类型>(源类型变量);
	
--》常类型转换
语法：
	目标变量 = const_cast<目标类型>(源类型变量);
适用场景：
	用于去除指针或引用的常属性.	
	
--》重解释类型转换
语法：
  目标变量=reinterpret_cast<目标类型>(源类型变量)
适用场景：
  ->在指针和整型数之间进行转换
  ->任意类型指针或引用之间进行转换	

  eg:向物理内存地址0x12345678,存放数据“123”
  int* paddr=reinterpret_cast<int*>(0x12345678);
  *paddr = 123;


小结：来自C++社区给C程序员建议
1 慎用宏,可以使用const、enum、inline
#define PAI 3.14
	--> const double PAI = 3.14;

#define SLEEP 0
#define RUN  1
#define STOP 2
	--> enum STATE{SLEEP,RUN,STOP};  

#define Max(a,b) ((a)>(b)?(a):(b)) 
	--> inline int Max(int a,int b){
				return a > b ? a : b;
		 }	
2 变量随用随声明同时初始化
3 尽量使用new/delete取代malloc/free
4 少用void*、指针计算、联合体和强制转换
5 尽量用string表示字符串，少用C风格char*/char[]
-----------------------------------------------

十二 类和对象//了解
1 什么是对象
  万物皆对象，任何一种事物都可以看做是对象
  
2 如何描述对象
  通过对象的属性(名词、数量词、形容词)和行为(动词)来描述和表达对象。
  
3 面向对象程序设计
  对自然世界中对象的观察引入到编程实践的一种理念和方法，这种方法被称为“数据抽象”，即描述对象时把细节的东西剥离出去，只考虑有规律性、一般性的、统一性的东西.
  
4 类
  类是将多个多个对象共性提取出来定义的一种新的数据类型，是对象 对象属性和行为的抽象描述.
  现实世界				 类					虚拟世界
  具体对象--抽象-->属性/行为--实例化-->具体对象	  
十三 类的定义和实例化
1 类的一般语法形式
  struct/class 类名:继承方式 基类{
  访问控制限定符:
  		类名(参数表):初始化列表{...}//构造函数
  		~类名(void){...}//析构函数
  		返回类型 函数名(参数表){...}//成员函数
  		数据类型 变量;//成员变量
  };
2 访问控制限定符
1）public：公有成员，任何位置都可以访问
2）private：私有成员，只有类中自己的成员函数可以问
3）protected：保护成员(后面讲)
注：struct定义类，类中成员的缺省访问控制属性是public，而如果使用class定义类，类中成员的缺省访问控制属性是private。
eg：
	struct/class XX{
		int a;//公有成员/私有成员
	private:
		int b;//私有成员
	public:
		int c;//公有成员
		int d;//公有成员
	private:
		int e;//私有成员
	};

项目：企业员工管理系统V1.0
需求：实现描述企业员工类
	1）工号大于10000
	2）姓名字符串长度小于20字符	
	3）工资大于0
	4）工资计算=基本工资+绩效工资
	   基本工资=工资*出勤率(输入出勤天数/23.0)
	   绩效工资=基本工资/2
提示：
	class Employee{
		//行为：打印信息、计算工资
		//属性：工号、姓名、工资
	};
	