回顾：
1 类的定义和实例化
1）访问控制属性：public、private
2）构造函数
	class 类名{
		类名(参数表){//负责对象初始化}
	};
3）对象创建和销毁
栈区：类名 对象(构造实参);
堆区：类名* 对象指针 = new 类名(构造实参);
      delete 对象指针;
4）多文件编程
xx.h//类的声明
	class XX{
		XX(...);
		返回类型 函数名(...);
		数据类型 变量名;
	};
xx.cpp//类的实现
	XX::XX(...){...}
	返回类型 XX::函数名(...){...}
	
十四 构造函数和初始化列表
1 构造函数可以重载，可以带有参数
2 缺省构造函数(无参构造函数)
3 类型转换构造函数(单参构造函数),explicit
4 拷贝构造函数，类名(const 类名& ){...}
5 初始化列表
	class 类名{
		类名(参数表):成员变量(初值),...{}
	};
1）以有参的方式初始化成员子对象，必须使用初始化列表
2）类中有“const”或“引用”成员变量，必须使用初始化列表
3）成员变量的初始化顺序由声明顺序决定，而与初始化列表的顺序无关，所以不要使用一个成员变量初始化另一个成员变量.


十五 this指针和常成员函数
1 this指针
1）类中成员函数(包含构造函数、析构函数)都隐藏一个当前类类型的指针参数，名为this，在成员函数中访问类中的其它成员，本质都是this指针来实现的:
--》对于普通成员函数，this指向调用对象的地址
--》对于构造函数，this指向正在创建的对象地址
	
2）多数情况，使用this指针显式访问类中成员和直接访问没有区别，但是以下的场景必须使用this指针：
--》区分作用域
--》从成员函数返回调用对象自身//重点掌握
--》从类的内部销毁对象自身
--》作为成员函数的实参，实现对象之间的交互//了解	
	
2 常成员函数(常函数)
1）在成员函数参数表后面加上const修饰，即为常成员函数
   返回类型 函数名(参数表) const {函数体}
2）常成员中的this指针是一个常指针，不能在常成员函数中直接修改成员变量的值.
  注：被mutable关键字修饰的成员变量，可以在常函数中直接修改.
3）非const对象既可以调用常函数也可以调用非常函数；但是常对象只能调用常函数，不能调用非常函数//重点掌握
  注：常对象也包括常指针和常引用
4）同一个类中，函数名和参数表相同的成员函数，其常版本和非常版本可以构成重载关系，常对象匹配常版本，非常对象匹配非常版本.

十六 析构函数(Destructor)
1 语法
	class 类名{
		~类名(void){
			//主要负责清理对象生命周期中的动态资源
		}
	};
	1）函数名必须是"~类名"
	2）没有返回类型，也没有参数
	3）析构函数不能被重载，一个类只能有一个析构函数
	
2 当对象被销毁时，该类的析构函数将自动被执行
1）栈对象离开所在作用域时，其析构函数被作用域终止的右花括号"}"自动调用.
2）堆对象的析构函数被delete操作符自动调用.
注：delete对象时，首先会调用析构函数，清理对象所维护的动态资源，再销毁对象自身内存；而如果是free仅能销毁对象自身的内存，不会调用析构函数.

3 如果类中自己没有显式定义析构函数，那么编译器会为该类提供一个缺省的析构函数：
--》对于基本类型成员变量什么也不做
--》对类 类型的成员变量(成员子对象),将会自动调用相应类的析构函数。

4 对象的创建和销毁过程
1）创建
--》分配内存
--》构造成员子对象(按声明顺序)
--》执行构造函数代码

2）销毁
--》执行析构函数代码
--》析构成员子对象(按声明逆序)
--》释放内存

项目：企业员工管理系统V3.0
需求：优化企业员工类
  1）构造函数改用初始化列表方式
  2）将打印信息函数声明为常成员函数
  3）创建员工对象时，将员工信息保存到文件中，文件名和工号一致。
  
提示：
	class Employee{
		构造函数(...):...{
			m_id(int)-->"m_id"(char*)//sprintf
			file = fopen("m_id","w");
			fprintf(...)
		}
		析构函数(void){
			fclose(file);
		}
		FILE* file;
	}；