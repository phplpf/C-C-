回顾：
1 拷贝构造和拷贝赋值
1 浅拷贝和深拷贝
2 拷贝赋值函数
  i1 = i2;//i1.operator=(i2)

2 静态成员(static)
1）静态成员变量，数据段(全局区)
2）静态成员函数，没有this指针
3）使用静态成员“类名::静态成员”

3 单例模式
1）私有化构造函数
2）静态成员变量维护唯一的对象
3）静态成员函数获取单例对象
4）实现方式：饿汉式和懒汉式

4 成员指针//了解

======================
今天：
二十 操作符重载
1 基本概念
  所谓的操作符重载就是一些具有特殊名字的函数，"operator 连接需要重载某个操作符",比如"operator="、"operator+"...,通过这样特殊的函数，把已定义的操作符重新定义，完成程序员想要的运算功能.

eg:复数(x+yi)
   (1+2i) + (3+4i) = 4+6i;
   
1 双目操作符重载 L#R
1.1 计算类双目操作符：+ - ...
--》左右操作数既可以是左值也可以是右值
--》表达式结果是右值，禁止对表达式结果再赋值
--》两种实现方式
  1）成员函数形式（左调右参）
  形如L#R表达式将会被编译器自动处理为L.operator#(R)的成员函数调用形式，由该函数完成运算功能，函数的返回结果就是表达式结果.
  L#R ==> L.operator#(R)
  
  2）全局函数形式(左右操作数都为参数)
  形如L#R表达式也可被编译器自动处理为operator#(L,R)的全局函数调用形式，由该函数完成运算功能，函数的返回结果就是表达式结果.
  L#R ==> operator#(L,R)
   
  注：通过friend关键字，可以把一个全局函数声明为某个类的友元，友元函数可以访问类中的任何成员。

1.2 赋值类双目操作符：+= -= ...
--》左操作数必须是左值，右操作数可以左值也可以是右值
--》表示式结果是左值，就是左操作数自身
--》两种实现方式
  1）成员函数形式：L#R ==> L.operator#(R)
  2）全局函数形式：L#R ==> operator#(L,R)
  
2 单目操作符的重载 #O
2.1 计算类单目操作符：~ -(取负) !...
--》操作数可以是左值也可以是右值
--》表达式结果是右值，禁止对表达式结果在赋值
--》两种实现方式
  1）成员函数形式：#O ==> O.operator#();
  2）全局函数形式：#O ==> operator#(O);

2.2 自增减单目操作符：++、--
1）前++、--
--》操作数一定是左值
--》表达式结果也只左值，就是操作数自身
  成员函数形式：#O ==> O.operator#();
  全局函数形式：#O ==> operator#(O);
  
2）后++、--
--》操作数一定是左值
--》表达式结果是右值，是操作数自增减前副本.
  成员函数形式：O# ==> O.operator#(int/*哑元*/);
  全局函数形式：O# ==> operator#(O,int/*哑元*/);
  
3 输出(插入)和输入(提取)操作符重载：<< >>
功能：实现自定义类型对象的直接输出或输入
注：只能使用全局函数形式(friend)

  #include <iostream>
  ostream //标准库中表示标准输出流类
  istream //标准库中表示标准输入流类
  
  ostream& operator<<(ostream& os,const RIGHT& r){
      //...
  		return os;
  }
  istream& operator<<(istream& is,RIGHT& r){
      //...
  		return is;
  }
  
  //全局函数：operator<<(cout,a)
  cout << a << b << c <<..;
  //全局函数：operator>>(cin,a)
  cin >> a;
 
4 下标操作符: []
功能：实现自定义类型的对象像数组一样使用
注：常对象返回右值，非常对象返回左值
  string s = "hello";
  s[0] = 'H'; //ok,s.operator[](0)
  const string& cs = s;
  cs[0] = 'H';//error,cs.operator[](0)
  
5 函数操作符：()
功能：实现自定义类型的对象像函数一样使用(仿函数)
注：对参数个数、参数类型和返回值类型没有任何限制
	class A{};
	A a;
	a(100,1.23);//a.operator()(100,1.23)

6 new/detele操作符
  static void* operator new(size_t size){...}
  static void operator delete(void* pv){...}
 
7 操作符重载的限制
1）不是所有符号都能重载，下列操作符不允许重载
--》作用域限定操作符 “::”
--》直接成员访问操作符 “.”
--》直接成员指针解引用操作符 ".*"
--》条件操作符 "?:"
--》字节长度操作符 "sizeof" 
--》类型信息操作符 "typeid"//后面讲
2）如果重载的操作符所有操作数都是基本类型，则无法被重载.
3）操作符重载不会改变预定义的优先级
4）操作符重载后无法改变操作数个数
5）无法通过操作符重载机制发明新的符号
6）只能使用成员函数形式重载的操作符： = () [] ->

项目：企业员工管理系统V5.0
需求：优化企业员工类
1）增加输出操作符重载
   friend ostream& operator<<(
   	ostream& os,const Employee& emp){}
   cout << emp << endl;
   
2）增加比较操作符重载：== !=
	bool operator==(int id)const{}
	bool operator!=(int id)const{}

	Employee emp(10001,...);
	if(emp == 10001){}//emp.opeartor==(10001)
	if(emp != 10001){}

练习：实现一个3*3矩阵类，支持如下操作符重载
	   + - += -= -(负) 前后++、-- <<
	   * *=
提示：
	class M33{
	public:
		M33(void){
			for(int i=0;i<3;i++)
				for(int j=0;j<3;j++)
					m_a[i][j] = 0;
		}
		M33(int a[][3]){
			for(int i=0;i<3;i++)
				for(int j=0;j<3;j++)
					m_a[i][j] = a[i][j];
		}
	private:
		int m_a[3][3];
	};
	int a1[3][3] = {1,2,3,4,5,6,7,8,9};
	int a2[3][3] = {9,8,7,6,5,4,3,2,1};
	M33 m1(a1);
	M33 m2(a2);
	m1+m2 ==> m1.operator+(m2)
	1 2 3		9 8 7		10 10 10
	4 5 6	+	6 5 4	 = 10 10 10
	7 8 9		3 2 1		10 10 10
	m1-m2 ==> m1.operator-(m2)
	1 2 3		9 8 7		-8 -6 -4
	4 5 6	-	6 5 4	 = -2  0  2
	7 8 9		3 2 1		 4  6  4
	m1*m2 ==> m1.operator*(m2)
	1 2 3		9 8 7		30  24  18
	4 5 6	*	6 5 4	 = 84  69  54
	7 8 9		3 2 1		138 114 90
	
